#import "template.typ": *

// Take a look at the file `template.typ` in the file panel
// to customize this template and discover how it works.
#show: project.with(
  title: "氢原子光谱和里伯德常数的测量",
  authors: (
    (name: "OverflowCat", email: "overflowcat@gmail.com"),
  ),
)

= 数据处理

== 校准光栅常数

=== 原始数据列表

#let d(int) = {
  let deg = calc.floor(int / 100)
  $deg degree #calc.mod(int, 100)'$
}

#let getdigit(angle) = {
    if angle < 0 {
        calc.ceil(angle / 100)
    } else {
        calc.floor(angle / 100)
    }
}

#let sum_angles(angle1, angle2) = {
    let angle1_deg = getdigit(angle1)
    let angle1_min = calc.mod(angle1, 100)
    let angle2_deg = getdigit(angle2)
    let angle2_min = calc.mod(angle2, 100)
    let degree_sum = angle1_deg + angle2_deg
    let minute_sum = angle1_min + angle2_min
    while minute_sum >= 60 {
        minute_sum -= 60
        degree_sum += 1
    }
    while minute_sum <= -60 {
        minute_sum += 60
        degree_sum -= 1
    }
    if degree_sum > 0 and minute_sum < 0 {
        minute_sum += 60
        degree_sum -= 1
    }
    if degree_sum < 0 and minute_sum > 0 {
        minute_sum -= 60
        degree_sum += 1
    }
    degree_sum * 100 + minute_sum
}

#assert(sum_angles(0, 0) == 0)
#assert(sum_angles(100, 100) == 200)
#assert(sum_angles(230, 130) == 400)
#assert(sum_angles(359, 1) == 400)
#assert(sum_angles(-123, -456) == -619)
#assert(sum_angles(-1150, -2110) == -3300)

#let coeff_angle(angle, coe) = {
  assert(coe <= 1, message: "Coeff should be leq than 1")
  assert(coe >= 0, message: "Coeff should be geq than 0")
  let aangle = calc.abs(angle)
  let angle_deg = getdigit(angle)
  let angle_min = calc.mod(angle, 100)
  angle_deg *= coe
  angle_min *= coe
  angle_min += calc.mod(angle_deg, 1) * 60
  angle_deg = calc.floor(angle_deg)
  angle_deg * 100 + calc.round(angle_min)
}

#assert(coeff_angle(102, .5) == 31, message: "Angle should be positive")

#let to_degreef(angle) = {
  let angle_deg = getdigit(angle)
  let angle_min = calc.mod(angle, 100)
  angle_deg += angle_min / 60
  angle_deg
}

#let calc_theta(a1, b1, a2, b2) = {
  coeff_angle(sum_angles(sum_angles(a1, -a2), sum_angles(b1, -b2)), .5)
}

#assert(calc_theta(5924, 23922, 1628, 19625) == 4257)
// (59 24 - 16 28 + 23922 - 19625) / 2
// = 42 56 + 42 57 = 42 56.5

#let line(a1, b1, a2, b2) = {
  (a1, b1, a2, b2, calc_theta(a1, b1, a2, b2)).map(d)
}

#let data = (
  (05924, 23922, 01628, 19625),
  (34901, 16903, 30556, 12653),
  (31246, 13243, 26943,  8940),
  (2826 + 36000, 20725, 34502, 16501),
  (15516, 33515, 11005, 29006),
)

#table(
  columns: (auto, auto, auto, auto, auto, auto),
  inset: 10pt,
  align: horizon,
  [*测量级次*], [$-2$], [$-2$], [$+2$], [$+2$], [],
  [*组数*], [$alpha_1$], [$beta_1$], [$alpha_2$], [$beta_2$], [$2 theta_i$],
  $1$, ..line(..data.at(0)),
  $2$, ..line(..data.at(1)),
  $3$, ..line(..data.at(2)),
  $4$, ..line(..data.at(3)),
  $5$, ..line(..data.at(4)),
)

=== 计算光栅常数

#let sum_multi_angles(arr) = {
  arr.fold(0, sum_angles)
}

#let double_thetas = data.map(x => calc_theta(..x))

#let double_theta_val = coeff_angle(sum_multi_angles(double_thetas), .2)

$ 2 overline(theta) = 1/5 sum^5_(i=1) theta_i = #d(double_theta_val), $

#let theta_val = int(coeff_angle(double_theta_val, .5))

$ theta = #d(theta_val) $

由 $d sin theta = k lambda$, $k=2$, 得

#let thetaf = to_degreef(theta_val)
#let to_rad = x => calc.pi / 180 * x
#let theta_rad = to_rad(thetaf)
#let sin_theta = calc.sin(theta_rad)
#let cos_theta = calc.sin(theta_rad)
#let d = 2 * 589.3 * 1e-9 / sin_theta

$ d = (k lambda) / (sin theta) = (2 times 589.3 times 10^(-9)) / (sin #calc.round(thetaf, digits: 3) degree) = #{calc.round(d, digits: 10) * 1e6} "μm" $

=== 计算不确定度 $u(d)$

#let diffs=double_thetas.map(to_degreef).map(to_rad). map(rad => rad / 2 - theta_rad)
$ u_"a"(2 theta) = sqrt(sum (theta_i - overline(theta))/(5 times 4))$
$ = sqrt(#{diffs.map(x => calc.round(x, digits: 3)).map(str).join("² + ") + "²"} / (5 times 4)) $
#let u_a_2theta = calc.sqrt(diffs.map(x => calc.pow(x, 2)).fold(0, (x, y) => x + y) / (5 * 4))
$ = #u_a_2theta "rad." $

$ u_"b"(2 theta) = Delta_(2 theta) / (2 sqrt(3)) = (1') / (2 sqrt(3)) = 8.397219 times 10^(-5) "rad." $

#let u_b_2theta = to_rad(1/60) / (2 * calc.sqrt(3))
#let u_2theta = calc.sqrt(u_a_2theta * u_a_2theta + u_b_2theta * u_b_2theta)
$ u(2 theta) = sqrt((u_"a"(theta))^2 + (u_"b"(theta))^2) = #u_2theta $
#let u_theta = 1/2 * u_2theta
$ u(theta) = u_2theta / 2 = #u_theta $
// #let u_d = calc.round(calc.sqrt(calc.pow(2 * 589.3 * 1e-9 * calc.cos(theta_rad) / calc.sin(theta_rad) * u_theta, 2)), digits: 14)

$ u(d) = sqrt(((diff d) / (diff theta)) ^ 2 u^2(theta)) = sqrt((-(k lambda cos x)/(sin^2 x)) ^ 2 u^2(theta)). $
#let u_d = calc.sqrt(calc.pow(-2 * 589.3 * 1e-9 * cos_theta / sin_theta / sin_theta, 2) * calc.pow(u_theta, 2))
$ = #calc.round(u_d, digits: 14) $
$ = #{u_d * 1e6} "μm" $

=== 最终表述

$ u(d) = 3.220 ± 0.006 "μm." $

// #let u_d_alt = d * (u_theta / calc.tan(theta_rad))
// $ u(d) = (cos theta)/((sin theta)^2) u(theta) = #u_d $
// $ = #{u_d_alt * 1e6} "μm" $
